% derivative.sty
% Copyright 2019 Simon Jensen
% 
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
% http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
% 
% This work has the LPPL maintenance status `maintained'.
% 
% The Current Maintainer of this work is Simon Jensen.

\NeedsTeXFormat{LaTeX2e}

\RequirePackage{xparse}[2018/05/09]
\ProvidesExplPackage{derivative}{2000/01/01}{1.0}{Nice and easy derivatives}

%%%%%  Useful conditionals  %%%%%

\prg_new_conditional:Npnn \__deriv_if_novalue:n #1 { T , F , TF }
{
	\tl_if_novalue:nTF {#1}
	{ \prg_return_true: }
	{
		\tl_if_blank:nTF {#1}
		{ \prg_return_true:  }
		{ \prg_return_false: }
	}
}

\prg_new_conditional:Npnn \__deriv_if_novalue_and:nn #1 #2 { F, TF }
{
	\__deriv_if_novalue:nTF {#1}
	{
		\__deriv_if_novalue:nTF {#2}
		{ \prg_return_true:  }
		{ \prg_return_false: }
	}
	{ \prg_return_false: }
}

\prg_new_conditional:Npnn \__deriv_show_order:N #1 { T, TF }
{
	\str_if_eq:NNTF #1 1
	{ \prg_return_false: }
	{ \prg_return_true:  }
}

\cs_new:Npn \__deriv_case:n #1
{ \exp:w \__deriv_case_begin:nTF {#1} { } { } }

\cs_new:Npn \__deriv_case:nT #1#2
{ \exp:w \__deriv_case_begin:nTF {#1} {#2} { } }

\cs_new:Npn \__deriv_case:nF #1#2
{ \exp:w \__deriv_case_begin:nTF {#1} { } {#2} }

\cs_new:Npn \__deriv_case:nTF #1
{ \exp:w \__deriv_case_begin:nTF {#1} }

\cs_new:Npn \__deriv_case_begin:nTF #1#2#3
{ \__deriv_case:w #1 \c_true_bool { } \q_mark {#2} \q_mark {#3} \q_stop }

\cs_new:Npn \__deriv_case:w #1#2
{
	\bool_if:nTF {#1}
	{ \__deriv_case_end:nw {#2} }
	{ \__deriv_case:w }
}

\cs_new:Npn \__deriv_case_end:nw #1#2#3 \q_mark #4#5 \q_stop
{ \exp_end: #1 #4 }

%%%%%  Variables for settings of odv, pdv and variants  %%%%%

\tl_new:N \l__deriv_cs_name_tl
\tl_new:N \l__deriv_derivset_tl

\seq_new:N \l__deriv_new_var_seq
\seq_new:N \l__deriv_rubber_seq

\prop_new:N \l__deriv_tmp_keys_prop
\seq_new:N \l__deriv_tmp_keys_seq
\tl_new:N \l__deriv_tmp_keys_tl

%%%%%  Variables for pdv and mixed order (mo)  %%%%%

\seq_new:N \l__deriv_dv_variant_seq

\tl_new:N \l__deriv_tmpa_tl
\tl_new:N \l__deriv_dv_denom_tl

\seq_new:N \l__deriv_dv_var_seq
\seq_new:N \l__deriv_dv_order_seq
\seq_new:N \l__deriv_dv_mo_seq

\int_new:N \l__deriv_vmo_int

\prop_const_from_keyval:Nn \c__deriv_dv_pkg_keys_prop
{
	style-frac    = \frac,
	style-frac-/  = \slashfrac,
	scale-eval    = auto,
	scale-eval-/  = auto,
	scale-fun     = auto,
	scale-var     = auto,
	scale-frac    = auto,
	scale-frac-/  = auto,
	delims-eval   = .\rvert,
	delims-eval-/ = .\rvert,
	delims-fun    = (),
	delims-var    = (),
	delims-frac   = (),
	delims-frac-/ = (),
	sep-inf-ord   = 0,
	sep-inf-fun   = 0,
	sep-ord-fun   = 0,
	sep-frac-fun  = 0,
	sep-inf-var   = 0,
	sep-var-ord   = 0,
	sep-var-inf   = \mathop{}\!,
	sep-ord-inf   = \mathop{}\!,
	sep-eval-sb   = 0,
	sep-eval-sp   = 0,
	switch-*      = false,
	switch-/      = false,
	misc-remove-delims  = {fun, var, frac},
	sort-method         = {sign, symbol, abs},
	sort-numerical      = auto,
	sort-abs-reverse    = false,
	sort-number-reverse = false,
	sort-sign-reverse   = false,
	sort-symbol-reverse = false,
	order = 1,
	morder = 1
}

\bool_lazy_or:nnTF { \sys_if_engine_luatex_p: } { \sys_if_engine_xetex_p: }
{ \prop_gput:Nnn \c__deriv_dv_pkg_keys_prop { style-inf } { \symnormal  } }
{ \prop_gput:Nnn \c__deriv_dv_pkg_keys_prop { style-inf } { \mathnormal } }

\tl_new:N \l__deriv_sym_tmpa_tl
\tl_new:N \l__deriv_num_tmpa_tl
\tl_new:N \l__deriv_sym_tmpb_tl
\tl_new:N \l__deriv_num_tmpb_tl
\tl_new:N \l__deriv_input_tl

\seq_new:N \l__deriv_input_seq
\seq_new:N \l__deriv_extract_seq
\seq_new:N \l__deriv_unsorted_seq
\seq_new:N \l__deriv_sorted_seq

\seq_new:N \l__deriv_symbol_seq
\seq_new:N \l__deriv_number_seq
\seq_new:N \l__deriv_rebuild_seq

\int_new:N \l__deriv_tmpa_int

\int_new:N \l__deriv_numerical_int
\int_new:N \l__deriv_sort_counter_int
\int_new:N \l__deriv_sort_max_int

\int_new:N \l__deriv_position_int
\int_new:N \l__deriv_rebuild_int

\regex_const:Nn \c__deriv_pattern_regex { \A([\+\-]?\d*)(.*) }
\regex_const:Nn \c__deriv_cs_numbers_regex { \A\-?\d+(?:,\d+){0,2}\Z }

%%%%%%  Key-val for all  %%%%%%

\prop_const_from_keyval:Nn \c__deriv_all_pkg_keys_prop
{ scale-auto = leftright }

\keys_define:nn { deriv/all/all }
{
	scale-auto .choice:,
	scale-auto / leftright .code:n =
	{
		\cs_set_eq:NN \__deriv_auto_left:n \left
		\cs_set_eq:NN \__deriv_auto_right:n \right
	},
	scale-auto / mleftmright .code:n =
	{
		\cs_set_nopar:Npn \__deriv_auto_left:n  { \mleft  }
		\cs_set_nopar:Npn \__deriv_auto_right:n { \mright }
	},
	scale-auto .default:n = { leftright }
}

%%%%%%  Key-val for derivatives  %%%%%%
\cs_new:Npn \__deriv_dv_define_keys:n #1
{
	\keys_define:nn { deriv/dv/#1 }
	{
		style-inf    .code:n = { \cs_set_eq:cN { __deriv_#1_style_inf:n } ##1 },
		style-frac   .code:n = { \cs_set_eq:cN { __deriv_#1_style_frac:nn } ##1 },
		style-frac-/ .code:n = { \cs_set_eq:cN { __deriv_#1_style_frac_slash:nn } ##1 },
		
		scale-eval   .choices:nn = { auto, none, big, Big, bigg, Bigg } { \tl_set_eq:cN { l__deriv_#1_scale_eval_tl       } \l_keys_choice_tl },
		scale-eval-/ .choices:nn = { auto, none, big, Big, bigg, Bigg } { \tl_set_eq:cN { l__deriv_#1_scale_eval_slash_tl } \l_keys_choice_tl },
		scale-fun    .choices:nn = { auto, none, big, Big, bigg, Bigg } { \tl_set_eq:cN { l__deriv_#1_scale_fun_tl        } \l_keys_choice_tl },
		scale-var    .choices:nn = { auto, none, big, Big, bigg, Bigg } { \tl_set_eq:cN { l__deriv_#1_scale_var_tl        } \l_keys_choice_tl },
		scale-frac   .choices:nn = { auto, none, big, Big, bigg, Bigg } { \tl_set_eq:cN { l__deriv_#1_scale_frac_tl       } \l_keys_choice_tl },
		scale-frac-/ .choices:nn = { auto, none, big, Big, bigg, Bigg } { \tl_set_eq:cN { l__deriv_#1_scale_frac_slash_tl } \l_keys_choice_tl },
		
		delims-eval   .code:n = { \tl_set:cn { l__deriv_#1_delims_eval_tl       } {##1} },
		delims-eval-/ .code:n = { \tl_set:cn { l__deriv_#1_delims_eval_slash_tl } {##1} },
		delims-fun    .code:n = { \tl_set:cn { l__deriv_#1_delims_fun_tl        } {##1} },
		delims-var    .code:n = { \tl_set:cn { l__deriv_#1_delims_var_tl        } {##1} },
		delims-frac   .code:n = { \tl_set:cn { l__deriv_#1_delims_frac_tl       } {##1} },
		delims-frac-/ .code:n = { \tl_set:cn { l__deriv_#1_delims_frac_slash_tl } {##1} },
		
		sep-inf-ord  .code:n = { \__deriv_set_rubber_length:cn { l__deriv_#1_sep_inf_ord_tl  } {##1} },
		sep-inf-fun  .code:n = { \__deriv_set_rubber_length:cn { l__deriv_#1_sep_inf_fun_tl  } {##1} },
		sep-ord-fun  .code:n = { \__deriv_set_rubber_length:cn { l__deriv_#1_sep_ord_fun_tl  } {##1} },
		sep-frac-fun .code:n = { \__deriv_set_rubber_length:cn { l__deriv_#1_sep_frac_fun_tl } {##1} },
		sep-inf-var  .code:n = { \__deriv_set_rubber_length:cn { l__deriv_#1_sep_inf_var_tl  } {##1} },
		sep-var-ord  .code:n = { \__deriv_set_rubber_length:cn { l__deriv_#1_sep_var_ord_tl  } {##1} },
		sep-var-inf  .code:n = { \__deriv_set_rubber_length:cn { l__deriv_#1_sep_var_inf_tl  } {##1} },
		sep-ord-inf  .code:n = { \__deriv_set_rubber_length:cn { l__deriv_#1_sep_ord_inf_tl  } {##1} },
		sep-eval-sb  .code:n = { \__deriv_set_rubber_length:cn { l__deriv_#1_sep_eval_sb_tl  } {##1} },
		sep-eval-sp  .code:n = { \__deriv_set_rubber_length:cn { l__deriv_#1_sep_eval_sp_tl  } {##1} },
		
		switch-* .bool_set:c = { l__deriv_#1_switch_star_bool },
		switch-/ .bool_set:c = { l__deriv_#1_switch_slash_bool },
		
		misc-add-delims    .multichoices:nn = { fun, var, frac } { \bool_set_true:c  { l__deriv_#1_mics_##1_bool } },
		misc-remove-delims .multichoices:nn = { fun, var, frac } { \bool_set_false:c { l__deriv_#1_mics_##1_bool } },
		
		order  .tl_set:c = { l__deriv_dv_#1_order_tl },
		morder .tl_set:c = { l__deriv_dv_#1_mix_ord_tl },
		
		sort-method         .clist_set:c = { l__deriv_#1_sort_method_clist },
		sort-numerical      .choices:nn  = { auto, first, last, symbolic } { \tl_set_eq:cN { l__deriv_#1_sort_numerical_tl } \l_keys_choice_tl },
		sort-abs-reverse    .bool_set:c  = { l__deriv_#1_sort_abs_reverse_bool    },
		sort-number-reverse .bool_set:c  = { l__deriv_#1_sort_number_reverse_bool },
		sort-sign-reverse   .bool_set:c  = { l__deriv_#1_sort_sign_reverse_bool   },
		sort-symbol-reverse .bool_set:c  = { l__deriv_#1_sort_symbol_reverse_bool }
	}
}

%%%%%  Setting keys  %%%%%

\DeclareDocumentCommand{\derivset}{ m o }
{
	\str_if_eq:nnTF {#1} { all }
	{
		\__deriv_set_default:nnn { all } {#2} { all }
		\keys_set:nn { deriv/all/all } { default }
	}
	{
		\tl_set:Nx \l__deriv_derivset_tl { \cs_to_str:N #1 }
		\deriv_set_keys:Vn \l__deriv_derivset_tl {#2}
	}
}
% dv, keyval
\cs_new_protected:Npn \deriv_set_keys:nn #1 #2
{
	\seq_if_in:NnTF \l__deriv_dv_variant_seq {#1}
	{ \__deriv_set_default:nnn {#1} {#2} { dv } }
	{
		\msg_error:nnxx { deriv } { derivative-not-defined }
		{ \token_to_str:N #1        }
		{ \token_to_str:N \derivset }
	}
}
%%%%%  Declaring variants  %%%%%

% tl-dv, macro, key-value
\cs_new_protected:Npn \deriv_dv_preamble:NNn #1 #2 #3
{
	\tl_set:Nx #1 { \cs_to_str:N #2 }
	\__deriv_preamble_aux:Vnn #1 {#3} { dv }
}
% dv, key-value, dv/inf
\cs_new_protected:Npn \__deriv_preamble_aux:nnn #1 #2 #3
{
	\seq_if_in:cnF { l__deriv_#3_variant_seq } {#1}
	{
		\seq_put_left:cn { l__deriv_#3_variant_seq } {#1}
		\use:c { __deriv_#3_variables:n   } {#1}
		\use:c { __deriv_#3_define_keys:n } {#1}
	}
	\__deriv_set_default:nnn {#1} {#2} {#3}
}
% dv, keyval, dv/inf
\cs_new_protected:Npn \__deriv_set_default:nnn #1 #2 #3
{
	\prop_set_eq:cc { l__deriv_#3_user_#1_keys_prop } { c__deriv_#3_pkg_keys_prop }
	
	\tl_if_novalue:nF {#2}
	{ \__deriv_update_prop:cn { l__deriv_#3_user_#1_keys_prop } {#2} }
	
	\__deriv_set_default_from_prop:Nc \l__deriv_tmp_keys_tl { l__deriv_#3_user_#1_keys_prop }
	\__deriv_set_default_aux:Vnn \l__deriv_tmp_keys_tl {#1} {#3}
}
% key-val, dv, dv/inf
\cs_new_protected:Npn \__deriv_set_default_aux:nnn #1 #2 #3
{
	\keys_define:nn {deriv/#3/#2}
	{ default .meta:n = {#1} }
}
% user-prop, key-val
\cs_new_protected:Npn \__deriv_update_prop:Nn #1 #2
{
	\prop_set_from_keyval:Nn \l__deriv_tmp_keys_prop {#2}
	\prop_map_inline:Nn \l__deriv_tmp_keys_prop { \prop_put:Nnn #1 {##1} {##2} }
}
% user-prop
\cs_new_protected:Npn \__deriv_set_default_from_prop:NN #1 #2
{
	\seq_clear:N \l__deriv_tmp_keys_seq
	\prop_map_inline:Nn #2 { \seq_put_right:Nn \l__deriv_tmp_keys_seq { ##1 = {##2} } }
	\tl_set:Nx #1 { \seq_use:Nn \l__deriv_tmp_keys_seq { , } }
}
% new/delare/renew/provide, dv, macro, inf
\cs_new_protected:Npn \deriv_dv_define:Nnnn #1 #2 #3 #4
{
	\exp_args:Nne #1 {#3}{ s O{} m t/ m !e{\char_generate:nn {`_}{8}^} }
	{
		\group_begin:
		\keys_set:nn { deriv/dv/#2 } { default, ##2 }
		
		\exp_args:Nnc \bool_xor:nnTF {##4} { l__deriv_#2_switch_slash_bool }
		{
			\exp_args:Nnc \bool_xor:nnTF {##1} { l__deriv_#2_switch_star_bool }
			{ \__deriv_dv_both:nnnnnn  {#4} {#2} {##3} {##5} {##6} {##7} }
			{ \__deriv_dv_slash:nnnnnn {#4} {#2} {##3} {##5} {##6} {##7} }
		}
		{
			\exp_args:Nnc \bool_xor:nnTF {##1} { l__deriv_#2_switch_star_bool }
			{ \__deriv_dv_star:nnnnnn {#4} {#2} {##3} {##5} {##6} {##7} }
			{ \__deriv_dv_none:nnnnnn {#4} {#2} {##3} {##5} {##6} {##7} }
		}
		\group_end:
	}
}
% dv
\cs_new_protected:Npn \__deriv_dv_variables:n #1
{
	\__deriv_new:nnnn { tl    } {#1} { style  } { inf, frac, frac_slash }
	\__deriv_new:nnnn { tl    } {#1} { scale  } { eval, eval_slash, fun, var, frac, frac_slash }
	\__deriv_new:nnnn { tl    } {#1} { delims } { eval, eval_slash, fun, var, frac, frac_slash }
	\__deriv_new:nnnn { tl    } {#1} { sep    } { inf_ord, inf_fun, ord_fun, frac_fun, inf_var, var_ord, var_inf, ord_inf, eval_sb, eval_sp }
	\__deriv_new:nnnn { bool  } {#1} { switch } { star, slash }
	\__deriv_new:nnnn { clist } {#1} { sort   } { method }
	\__deriv_new:nnnn { tl    } {#1} { sort   } { numerical }
	\__deriv_new:nnnn { bool  } {#1} { sort   } { abs_reverse, sign_reverse, symbol_reverse, number_reverse }
	\__deriv_new:nnnn { bool  } {#1} { mics   } { fun, var, frac }
	\tl_new:c { l__deriv_dv_#1_order_tl }
	\tl_new:c { l__deriv_dv_#1_mix_ord_tl }
	\prop_new:c { l__deriv_dv_user_#1_keys_prop }
}
% data-type, dv, category, cs-var-list
\cs_new:Npn \__deriv_new:nnnn #1 #2 #3 #4
{
	\seq_set_from_clist:Nn \l__deriv_new_var_seq {#4}
	\seq_map_inline:Nn \l__deriv_new_var_seq
	{ \cs:w #1_new:c \cs_end: { l__deriv_#2_#3_##1_#1 } }
}

%%%%%  Partial derivative definition  %%%%%
% inf, dv, function, variable, sb-point, sp-point
\cs_new_protected:Npn \__deriv_dv_both:nnnnnn #1 #2 #3 #4 #5 #6
{
	\__deriv_dv_preparation:Nnnn \l__deriv_dv_denom_tl {#1} {#2} {#4}
	\__deriv_evaluation_slash:nnnn {#2} {#5} {#6}
	{
		\__deriv_fraction_slash:nn {#2}
		{
			\use:c { __deriv_#2_style_frac_slash:nn }
			{ \__deriv_dv_numerator_nofun:nn {#1} {#2} }
			{ \__deriv_dv_denominator:n {#2} }
		}
		\__deriv_insert_fun:nnn {#2} {#3} { frac_fun }
	}
}
% inf, dv, function, variable, sb-point, sp-point
\cs_new_protected:Npn \__deriv_dv_star:nnnnnn #1 #2 #3 #4 #5 #6
{
	\__deriv_dv_preparation:Nnnn \l__deriv_dv_denom_tl {#1} {#2} {#4}
	\__deriv_evaluation:nnnn {#2} {#5} {#6}
	{
		\__deriv_fraction:nn {#2}
		{
			\use:c { __deriv_#2_style_frac:nn }
			{ \__deriv_dv_numerator_nofun:nn {#1} {#2} }
			{ \__deriv_dv_denominator:n {#2} }
		}
		\__deriv_insert_fun:nnn {#2} {#3} { frac_fun }
	}
}
% inf, dv, function, variable, sb-point, sp-point
\cs_new_protected:Npn \__deriv_dv_slash:nnnnnn #1 #2 #3 #4 #5 #6
{
	\__deriv_dv_preparation:Nnnn \l__deriv_dv_denom_tl {#1} {#2} {#4}
	\__deriv_evaluation_slash:nnnn {#2} {#5} {#6}
	{
		\__deriv_fraction_slash:nn {#2}
		{
			\use:c { __deriv_#2_style_frac_slash:nn }
			{ \__deriv_dv_numerator_fun:nnn {#1} {#2} {#3} }
			{ \__deriv_dv_denominator:n {#2} }
		}
	}
}
% inf, dv, function, variable, sb-point, sp-point
\cs_new_protected:Npn \__deriv_dv_none:nnnnnn #1 #2 #3 #4 #5 #6
{
	\__deriv_dv_preparation:Nnnn \l__deriv_dv_denom_tl {#1} {#2} {#4}
	\__deriv_evaluation:nnnn {#2} {#5} {#6}
	{
		\__deriv_fraction:nn {#2}
		{
			\use:c { __deriv_#2_style_frac:nn }
			{ \__deriv_dv_numerator_fun:nnn {#1} {#2} {#3} }
			{ \__deriv_dv_denominator:n {#2} }
		}
	}
}% inf, dv, function
\cs_new_protected:Npn \__deriv_dv_numerator_fun:nnn #1 #2 #3
{
	\__deriv_insert_inf:nn {#1} {#2}
	\__deriv_show_order:cTF { l__deriv_dv_#2_mix_ord_tl }
	{
		\__deriv_insert_ord:cnn { l__deriv_dv_#2_mix_ord_tl } {#2} { inf_ord }
		\__deriv_insert_fun:nnn {#2} {#3} { ord_fun }
	}
	{ \__deriv_insert_fun:nnn {#2} {#3} { inf_fun } }
}
% inf, dv
\cs_new_protected:Npn \__deriv_dv_numerator_nofun:nn #1 #2
{
	\__deriv_insert_inf:nn {#1} {#2}
	\__deriv_show_order:cT { l__deriv_dv_#2_mix_ord_tl }
	{ \__deriv_insert_ord:cnn { l__deriv_dv_#2_mix_ord_tl } {#2} { inf_ord } }
}
% dv
\cs_new_protected:Npn \__deriv_dv_denominator:n #1
{ \tl_use:N \l__deriv_dv_denom_tl }
% denom-tl, inf, dv, variable
\cs_new_protected:Npn \__deriv_dv_preparation:Nnnn #1 #2 #3 #4
{
	\tl_clear:N #1
	\seq_set_from_clist:Nn \l__deriv_dv_var_seq {#4}
	
	\seq_set_from_clist:Nc \l__deriv_dv_order_seq { l__deriv_dv_#3_order_tl }
	
	\__deriv_adjust_ord_seq:NN \l__deriv_dv_var_seq \l__deriv_dv_order_seq
	
	\str_if_eq:cNT { l__deriv_dv_#3_mix_ord_tl } 1 
	{ \__deriv_mixed_order:cNn { l__deriv_dv_#3_mix_ord_tl } \l__deriv_dv_order_seq {#3} }
	
	\__deriv_dv_build_denom:NNNnn \l__deriv_dv_var_seq \l__deriv_dv_order_seq #1 {#2} {#3}
}
% var_seq, order_seq
\cs_new_protected:Npn \__deriv_adjust_ord_seq:NN #1 #2
{
	\int_set:Nn \l__deriv_vmo_int { \seq_count:N #1 - \seq_count:N #2 }
	
	\int_compare:nNnF { \l__deriv_vmo_int } = { 0 }
	{
		\int_compare:nNnTF { \l__deriv_vmo_int } < { 0 }
		{
			\int_step_inline:nn { -1 * \l__deriv_vmo_int }
			{ \seq_pop_right:NN #2 \l__deriv_tmpa_tl }
		}
		{
			\int_step_inline:nn { \l__deriv_vmo_int }
			{ \seq_put_right:Nn #2 { 1 } }
		}
	}
}
% var_seq, order_seq, denom-tl, inf, dv
\cs_new_protected:Npn \__deriv_dv_build_denom:NNNnn #1 #2 #3 #4 #5
{
	\int_set:Nn \l__deriv_tmpa_int { \seq_count:N #1 }
	
	\seq_map_inline:Nn #1
	{
		\int_decr:N \l__deriv_tmpa_int
		\seq_pop_left:NN #2 \l__deriv_tmpa_tl
		\tl_put_right:Nx #3
		{
			\__deriv_insert_inf:nn {#4} {#5}
			\__deriv_insert_mskip:nn {#5} { inf_var }
			\__deriv_insert_var:nn {#5} {##1}
			\__deriv_show_order:NTF \l__deriv_tmpa_tl
			{
				\__deriv_insert_ord:Nnn \l__deriv_tmpa_tl {#5} { var_ord }
				\int_compare:nNnF { \l__deriv_tmpa_int } = { 0 }
				{ \__deriv_insert_mskip:nn {#5} { ord_inf } }
			}
			{
				\int_compare:nNnF { \l__deriv_tmpa_int } = { 0 }
				{ \__deriv_insert_mskip:nn {#5} { var_inf } }
			}
		}
	}
}
%%%%%  And the rest of the code  %%%%%
% inf, dv
\cs_new:Npn \__deriv_insert_inf:nn #1 #2
{ \exp_not:n { \use:c { __deriv_#2_style_inf:n } {#1} } }
% dv, function, muskip
\cs_new:Npn \__deriv_insert_fun:nnn #1 #2 #3
{
	\tl_if_blank:nF {#2}
	{
		\__deriv_insert_mskip:nn {#1} {#3}
		\exp_not:n { \__deriv_function:nn {#1} {#2} }
	}
}
% dv, variable
\cs_new:Npn \__deriv_insert_var:nn #1 #2
{ \exp_not:n { \__deriv_variable:nn {#1} {#2} } }
% order, dv, name
\cs_new:Npn \__deriv_insert_ord:Nnn #1 #2 #3
{
	\sp
	{
		\__deriv_insert_mskip:nn {#2} {#3}
		\tl_use:N #1
	}
}
% dv, name
\cs_new:Npn \__deriv_insert_mskip:nn #1 #2
{
	\str_if_eq:vnF { l__deriv_#1_sep_#2_tl } { \mskip0mu }
	{ \tl_use:c { l__deriv_#1_sep_#2_tl } }
}
% muskip, length
\cs_new:Npn \__deriv_set_rubber_length:Nn #1 #2
{
	\regex_match:NnTF \c__deriv_cs_numbers_regex {#2}
	{
		\seq_set_split:Nnn \l__deriv_rubber_seq { , } {#2}
		
		\tl_set:Nf #1 { \seq_use:Nnnn \l__deriv_rubber_seq { mu plus } { mu plus } { mu minus } mu }
		\tl_put_left:Nn #1 { \mskip }
	}
	{ \tl_set:Nn #1 {#2} }
}

%%%%%  Scale, delimiters, evaluation  %%%%%
% dv, function
\cs_new:Npn \__deriv_function:nn #1 #2
{
	\bool_if:cTF { l__deriv_#1_mics_fun_bool }
	{ \__deriv_add_delims:nnn {#1} { fun } {#2} }
	{#2}
}
% dv, variable
\cs_new:Npn \__deriv_variable:nn #1 #2
{
	\bool_if:cTF { l__deriv_#1_mics_var_bool }
	{ \__deriv_add_delims:nnn {#1} { var } {#2} }
	{ \__deriv_handle_double_sp:n {#2} }
}
% variable
\cs_new:Npn \__deriv_handle_double_sp:n #1
{
	\str_if_in:nnTF {#1} { ^ }
	{
		\str_case_e:nnF { ^ }
		{
			{ \tl_item:nn {#1} {-2} } { {#1} }
			{ \tl_item:nn {#1} {-4} } { {#1} }
		}
		{#1}
	}
	{#1}
}
% dv, code-for-fraction
\cs_new:Npn \__deriv_fraction:nn #1 #2
{
	\bool_if:cTF { l__deriv_#1_mics_frac_bool }
	{ \__deriv_add_delims:nnn {#1} { frac } {#2} }
	{#2}
}
% dv, code-for-fraction
\cs_new:Npn \__deriv_fraction_slash:nn #1 #2
{
	\bool_if:cTF { l__deriv_#1_mics_frac_bool }
	{ \__deriv_add_delims:nnn {#1} { frac_slash } {#2} }
	{#2}
}
% dv, sub, sup, code-for-fraction
\cs_new:Npn \__deriv_evaluation:nnnn #1 #2 #3 #4
{
	\__deriv_if_novalue_and:nnTF {#2} {#3}
	{#4}
	{
		\__deriv_add_delims:nnn {#1} { eval } {#4}
		\__deriv_if_novalue:nF {#2} { \sb{ \__deriv_insert_mskip:nn {#1} { eval_sb } #2 } }
		\__deriv_if_novalue:nF {#3} { \sp{ \__deriv_insert_mskip:nn {#1} { eval_sp } #3 } }
	}
}
% dv, sub, sup, code-for-fraction
\cs_new:Npn \__deriv_evaluation_slash:nnnn #1 #2 #3 #4
{
	\__deriv_if_novalue_and:nnTF {#2} {#3}
	{#4}
	{
		\__deriv_add_delims:nnn {#1} { eval_slash } {#4}
		\__deriv_if_novalue:nF {#2} { \sb{ \__deriv_insert_mskip:nn {#1} { eval_sb } #2 } }
		\__deriv_if_novalue:nF {#3} { \sp{ \__deriv_insert_mskip:nn {#1} { eval_sp } #3 } }
	}
}
% dv, name, value
\cs_new:Npn \__deriv_add_delims:nnn #1 #2 #3
{
	\__deriv_scale_left:nn {#1} {#2}
	{#3}
	\__deriv_scale_right:nn {#1} {#2}
}
% dv, name
\cs_new:Npn \__deriv_scale_left:nn #1 #2
{
	\exp_args:Nv \str_case:nnF { l__deriv_#1_scale_#2_tl }
	{
		{ auto } { \__deriv_scale_auto:Nnnn \__deriv_auto_left:n {#1} {#2} { 1 } }
		{ none } { \__deriv_scale_none:nnn {#1} {#2} { 1 } }
	}
	{ \__deriv_scale_big:nnnn {#1} {#2} { 1 } { l } }
}
% dv, name
\cs_new:Npn \__deriv_scale_right:nn #1 #2
{
	\exp_args:Nv \str_case:nnF { l__deriv_#1_scale_#2_tl }
	{
		{ auto } { \__deriv_scale_auto:Nnnn \__deriv_auto_right:n {#1} {#2} { 2 } }
		{ none } { \__deriv_scale_none:nnn {#1} {#2} { 2 } }
	}
	{ \__deriv_scale_big:nnnn {#1} {#2} { 2 } { r } }
}
% left/right, dv, name, number
\cs_new:Npn \__deriv_scale_auto:Nnnn #1 #2 #3 #4
{ #1 \tl_item:cn { l__deriv_#2_delims_#3_tl } {#4} }
% dv, name, number
\cs_new:Npn \__deriv_scale_none:nnn #1 #2 #3
{ \str_if_eq:cNF { l__deriv_#1_delims_#2_tl } . { \tl_item:cn { l__deriv_#1_delims_#2_tl } {#3} } }
% dv, name, number, l/r
\cs_new:Npn \__deriv_scale_big:nnnn #1 #2 #3 #4
{ \tl_use:c { \tl_use:c { l__deriv_#1_scale_#2_tl } #4 } { \tl_item:cn { l__deriv_#1_delims_#2_tl } {#3} } }

%%%%%  Calculation of mixed order  %%%%%
% mixed-order-tl, mixed-order-seq, dv
\cs_new:Npn \__deriv_mixed_order:NNn #1 #2 #3
{
	\__deriv_replace:NN \l__deriv_input_seq #2
	\__deriv_seq_counting:N \l__deriv_input_seq
	\__deriv_combine_seq:Nn \l__deriv_unsorted_seq {#3}
	\__deriv_sort:NNn \l__deriv_sorted_seq \l__deriv_unsorted_seq {#3}
	\__deriv_output:NNNn #1 \l__deriv_sorted_seq \l__deriv_numerical_int {#3}
}
% input-seq, mixed-order-seq
\cs_new_protected:Npn \__deriv_replace:NN #1 #2
{
	\tl_set:Nf \l__deriv_input_tl { \seq_use:Nn #2 { , } }
	\tl_remove_all:Nn \l__deriv_input_tl { ~ }
	\tl_replace_all:Nnn \l__deriv_input_tl { -- } { , }
	\tl_replace_all:Nnn \l__deriv_input_tl { - } { ,- }
	\tl_replace_all:Nnn \l__deriv_input_tl { + } { , }
	
	\exp_args:NNV \seq_set_from_clist:Nn #1 \l__deriv_input_tl
}
% input-seq
\cs_new_protected:Npn \__deriv_seq_counting:N #1
{
	\seq_clear:N \l__deriv_symbol_seq
	\seq_clear:N \l__deriv_number_seq
	
	\seq_map_inline:Nn #1
	{
		\__deriv_extract:NNn \l__deriv_sym_tmpa_tl \l__deriv_num_tmpa_tl {##1}
		
		\seq_if_in:NVTF \l__deriv_symbol_seq \l__deriv_sym_tmpa_tl
		{ \__deriv_update_seq:NN \l__deriv_sym_tmpa_tl \l__deriv_num_tmpa_tl }
		{ \__deriv_add_to_seq:NN \l__deriv_sym_tmpa_tl \l__deriv_num_tmpa_tl }
	}
}
% sym-tl, num-tl, seq-item
\cs_new_protected:Npn \__deriv_extract:NNn #1 #2 #3
{
	\regex_extract_once:NnN \c__deriv_pattern_regex {#3} \l__deriv_extract_seq
	\seq_pop_right:NN \l__deriv_extract_seq #1
	\seq_pop_right:NN \l__deriv_extract_seq #2
	
	\exp_args:NV \str_case:nn #2
	{
		{   } { \tl_set:Nn #2 {  1 } }
		{ - } { \tl_set:Nn #2 { -1 } }
	}
}
% unsorted-seq, dv
\cs_new:Npn \__deriv_combine_seq:Nn #1 #2
{
	\seq_clear:N #1
	\int_zero:N \l__deriv_numerical_int
	\seq_map_inline:Nn \l__deriv_symbol_seq
	{
		\seq_pop_left:NN \l__deriv_number_seq \l__deriv_num_tmpa_tl
		\__deriv_eval_term:NVnn #1 \l__deriv_num_tmpa_tl {##1} {#2}
	}
}
% unsorted-seq, num-tl, seq-item (sym), dv
\cs_new_protected:Npn \__deriv_eval_term:Nnnn #1 #2 #3 #4
{
	\__deriv_case:nF
	{
		{ \tl_if_empty_p:n   {#3}          } { \__deriv_numerical_term:Nnn #1 {#2} {#4} }
		{ \int_compare_p:nNn {#2} = {  1 } } { \seq_put_left:Nn #1 {#3}    }
		{ \int_compare_p:nNn {#2} = {  0 } } { \prg_do_nothing:            }
		{ \int_compare_p:nNn {#2} = { -1 } } { \seq_put_left:Nn #1 { -#3 } }
	}
	{ \seq_put_left:Nn #1 {#2#3} }
}
% unsorted-seq, num-tl, dv
\cs_new_protected:Npn \__deriv_numerical_term:Nnn #1 #2 #3
{
	\str_if_eq:vnTF { l__deriv_#3_sort_numerical_tl } { symbolic }
	{ \seq_put_left:Nn #1 {#2} }
	{ \int_set:Nn \l__deriv_numerical_int {#2} }
}
% sym-tl, num-tl
\cs_new_protected:Npn \__deriv_add_to_seq:NN #1 #2
{
	\seq_put_left:NV \l__deriv_symbol_seq #1
	\seq_put_left:NV \l__deriv_number_seq #2
}
% sym-tl, num-tl
\cs_new_protected:Npn \__deriv_update_seq:NN #1 #2
{
	\__deriv_get_position:NN \l__deriv_position_int #1
	\__deriv_rebuild_seq:NNN \l__deriv_number_seq \l__deriv_position_int #2
}
% position-int, sym-tl
\cs_new:Npn \__deriv_get_position:NN #1 #2
{
	\int_zero:N #1
	\seq_map_inline:Nn \l__deriv_symbol_seq
	{
		\int_incr:N #1
		\exp_args:NV \tl_if_eq:nnT #2 {##1} { \seq_map_break: }
	}
}
% num-seq, position-int, num-tl
\cs_new_protected:Npn \__deriv_rebuild_seq:NNN #1 #2 #3
{	
	\int_zero:N \l__deriv_rebuild_int
	\seq_clear:N \l__deriv_rebuild_seq
	
	\seq_map_inline:Nn #1
	{
		\int_incr:N \l__deriv_rebuild_int
		\int_compare:nNnTF \l__deriv_rebuild_int = #2
		{
			\tl_set:Nf \l__deriv_num_tmpb_tl { \int_eval:n { ##1 + #3 } }
			\seq_put_right:NV \l__deriv_rebuild_seq \l__deriv_num_tmpb_tl
		}
		{ \seq_put_right:Nn \l__deriv_rebuild_seq {##1} }
	}
	\seq_set_eq:NN #1 \l__deriv_rebuild_seq
}
% sorted-seq, unsorted-seq, dv
\cs_new_protected:Npn \__deriv_sort:NNn #1 #2 #3
{
	\int_set:Nn \l__deriv_sort_max_int { \int_min:nn { 3 } { \clist_count:c { l__deriv_#3_sort_method_clist } } }
	
	\seq_sort:Nn #2
	{
		\__deriv_extract:NNn \l__deriv_sym_tmpa_tl \l__deriv_num_tmpa_tl {##1}
		\__deriv_extract:NNn \l__deriv_sym_tmpb_tl \l__deriv_num_tmpb_tl {##2}
		\int_zero:N \l__deriv_sort_counter_int
		\__deriv_sort_method:n {#3}
	}
	\seq_set_eq:NN #1 #2
}
% dv
\cs_new_protected:Npn \__deriv_sort_method:n #1
{
	\int_incr:N \l__deriv_sort_counter_int
	
	\exp_args:Nf
	\str_case:nn { \clist_item:cn { l__deriv_#1_sort_method_clist } { \l__deriv_sort_counter_int } }
	{
		{ sign   } { \__deriv_sort_sign:n   {#1} }
		{ symbol } { \__deriv_sort_symbol:n {#1} }
		{ abs    } { \__deriv_sort_abs:n    {#1} }
		{ number } { \__deriv_sort_number:n {#1} }
	}
}
% dv
\cs_new_protected:Npn \__deriv_sort_sign:n #1
{
	\__deriv_case:nF
	{
		{ \tl_if_head_eq_charcode_p:VN \l__deriv_num_tmpb_tl - && ! \tl_if_head_eq_charcode_p:VN \l__deriv_num_tmpa_tl - } { \__deriv_sort_reverse:nnn {#1} { sign } { same    } }
		{ \tl_if_head_eq_charcode_p:VN \l__deriv_num_tmpa_tl - && ! \tl_if_head_eq_charcode_p:VN \l__deriv_num_tmpb_tl - } { \__deriv_sort_reverse:nnn {#1} { sign } { swapped } }
	}
	{
		\int_compare:nNnTF { \l__deriv_sort_counter_int } = { \l__deriv_sort_max_int }
		{ \sort_return_same:          }
		{ \__deriv_sort_method:n {#1} }
	}
}
% dv
\cs_new_protected:Npn \__deriv_sort_symbol:n #1
{
	\__deriv_case:nF
	{
		{ \int_compare_p:nNn { \tl_count:N \l__deriv_sym_tmpa_tl } > { \tl_count:N \l__deriv_sym_tmpb_tl }  } {  \__deriv_sort_reverse:nnn {#1} { symbol } { same    } }
		{ \int_compare_p:nNn { \tl_count:N \l__deriv_sym_tmpa_tl } < { \tl_count:N \l__deriv_sym_tmpb_tl }  } {  \__deriv_sort_reverse:nnn {#1} { symbol } { swapped } }
	}
	{
		\int_compare:nNnTF { \l__deriv_sort_counter_int } = { \l__deriv_sort_max_int }
		{ \sort_return_same:          }
		{ \__deriv_sort_method:n {#1} }
	}
}
% dv
\cs_new_protected:Npn \__deriv_sort_abs:n #1
{
	\__deriv_case:nF
	{
		{ \int_compare_p:nNn { \int_abs:n \l__deriv_num_tmpa_tl } > { \int_abs:n \l__deriv_num_tmpb_tl } } { \__deriv_sort_reverse:nnn {#1} { abs } { same    } }
		{ \int_compare_p:nNn { \int_abs:n \l__deriv_num_tmpa_tl } < { \int_abs:n \l__deriv_num_tmpb_tl } } { \__deriv_sort_reverse:nnn {#1} { abs } { swapped } }
	}
	{
		\int_compare:nNnTF { \l__deriv_sort_counter_int } = { \l__deriv_sort_max_int }
		{ \sort_return_same:          }
		{ \__deriv_sort_method:n {#1} }
	}
}
% dv
\cs_new_protected:Npn \__deriv_sort_number:n #1
{
	\__deriv_case:nF
	{
		{ \int_compare_p:nNn { \l__deriv_num_tmpa_tl } > { \l__deriv_num_tmpb_tl } } { \__deriv_sort_reverse:nnn {#1} { number } { same    } }
		{ \int_compare_p:nNn { \l__deriv_num_tmpa_tl } < { \l__deriv_num_tmpb_tl } } { \__deriv_sort_reverse:nnn {#1} { number } { swapped } }
	}
	{
		\int_compare:nNnTF { \l__deriv_sort_counter_int } = { \l__deriv_sort_max_int }
		{ \sort_return_same:          }
		{ \__deriv_sort_method:n {#1} }
	}
}
% dv, sort-method, same/swapped
\cs_new_protected:Npn \__deriv_sort_reverse:nnn #1 #2 #3
{
	\exp_args:Nc
	\bool_xor:nnTF { l__deriv_#1_sort_#2_reverse_bool } { \str_if_eq_p:nn {#3} { same } }
	{ \sort_return_same:    }
	{ \sort_return_swapped: }
}
% mixed-order-tl, sorted-seq, numerical-term, dv
\cs_new_protected:Npn \__deriv_output:NNNn #1 #2 #3 #4
{
	\tl_set:Nf #1 { \seq_use:Nn #2 { + } }
	
	\int_compare:nNnF {#3} = { 0 }
	{
		\tl_if_empty:NTF #1
		{ \tl_put_left:NV #1 #3 }
		{
			\exp_args:Nv \str_case:nnF { l__deriv_#4_sort_numerical_tl }
			{
				{ last  } { \tl_put_right:Nx #1 { + \int_use:N #3 } }
				{ first } { \tl_put_left:Nx  #1 { \int_use:N #3 + } }
			}
			{
				\bool_if:nTF { \tl_if_head_eq_charcode_p:VN #1 - }
				{ \tl_put_left:NV  #1 #3 }
				{ \tl_put_right:Nx #1 { + \int_use:N #3 } }
			}
		}
	}
	\tl_replace_all:Nnn #1 { +- } { - }
	\tl_if_empty:NT #1 { \tl_set:Nn #1 { 0 } }
}

%%%%%  Declaring Variant  %%%%%

\DeclareDocumentCommand{\NewDerivative}{ m m o }
{
	\cs_if_exist:NTF #1
	{
		\msg_error:nnxx { deriv } { command-already-defined }
		{ \token_to_str:N #1             }
		{ \token_to_str:N \NewDerivative }
	}
	{
		\deriv_dv_preamble:NNn \l__deriv_cs_name_tl #1 {#3}
		\deriv_dv_define:NVnn \NewDocumentCommand \l__deriv_cs_name_tl {#1} {#2}
	}
}

\DeclareDocumentCommand{\RenewDerivative}{ m m o }
{
	\cs_if_exist:NTF #1
	{
		\deriv_dv_preamble:NNn \l__deriv_cs_name_tl #1 {#3}
		\deriv_dv_define:NVnn \RenewDocumentCommand \l__deriv_cs_name_tl {#1} {#2}
	}
	{
		\msg_error:nnxx { deriv } { command-already-defined }
		{ \token_to_str:N #1               }
		{ \token_to_str:N \RenewDerivative }
	}
}

\DeclareDocumentCommand{\ProvideDerivative}{ m m o }
{
	\cs_if_exist:NF #1
	{
		\deriv_dv_preamble:NNn \l__deriv_cs_name_tl #1 {#3}
		\deriv_dv_define:NVnn \ProvideDocumentCommand \l__deriv_cs_name_tl {#1} {#2}
	}
}

\DeclareDocumentCommand{\DeclareDerivative}{ m m o }
{
	\deriv_dv_preamble:NNn \l__deriv_cs_name_tl #1 {#3}
	\deriv_dv_define:NVnn \DeclareDocumentCommand \l__deriv_cs_name_tl {#1} {#2}
}

%%%%%  slash frac  %%%%%

\DeclareDocumentCommand{\slashfrac}{ o m m }
{
	\tl_if_novalue:nTF {#1}
	{ \__deriv_slashfrac_auto:nn {#2} {#3} }
	{
		\str_case:nnF {#1}
		{
			{ auto } { \__deriv_slashfrac_auto:nn {#2} {#3} }
			{ none } { \__deriv_slashfrac_none:nn {#2} {#3} }
		}
		{ \__deriv_slashfrac_scale:nnn {#1} {#2} {#3} }
	}
}
% numerator, denominator
\cs_new_protected:Npn \__deriv_slashfrac_auto:nn #1 #2
{
	\__deriv_auto_left:n  . \kern-\nulldelimiterspace
	{#1} \middle/ {#2}
	\__deriv_auto_right:n . \kern-\nulldelimiterspace
}
% numerator, denominator
\cs_new_protected:Npn \__deriv_slashfrac_none:nn #1 #2
{ {#1} / {#2} }
% scale, numerator, denominator
\cs_new_protected:Npn \__deriv_slashfrac_scale:nnn #1 #2 #3
{
	\cs:w #1 l \cs_end: .
	{#2} 
	\cs:w #1   \cs_end: /
	{#3}
	\cs:w #1 r \cs_end: .
}

%%%%%  Generate variants  %%%%%

\prg_generate_conditional_variant:Nnn \__deriv_show_order:N { c } { T, TF }

\cs_generate_variant:Nn \tl_if_head_eq_charcode_p:nN { V }
\cs_generate_variant:Nn \__deriv_set_rubber_length:Nn { c }
\cs_generate_variant:Nn \__deriv_dv_variables:n { V }
\cs_generate_variant:Nn \__deriv_dv_define_keys:n { V }
\cs_generate_variant:Nn \deriv_dv_define:Nnnn { NV }
\cs_generate_variant:Nn \deriv_set_keys:nn { V }

\cs_generate_variant:Nn \__deriv_insert_ord:Nnn { c }

\cs_generate_variant:Nn \__deriv_if_novalue:nT { f }
\cs_generate_variant:Nn \__deriv_if_novalue:nTF { V }
\cs_generate_variant:Nn \__deriv_mixed_order:NNn { c }
\cs_generate_variant:Nn \__deriv_eval_term:Nnnn { NV }

\cs_generate_variant:Nn \__deriv_set_default_aux:nnn { V }
\cs_generate_variant:Nn \__deriv_set_default_from_prop:NN { Nc }
\cs_generate_variant:Nn \__deriv_update_prop:Nn { c }
\cs_generate_variant:Nn \__deriv_preamble_aux:nnn { V }

%%%%%   Messages   %%%%%

\msg_new:nnnn { deriv } { command-already-defined }
{ Command~'#1'~already~defined! }
{
	You~have~used~#2~with~a~command~that~already~has~a~definition. \\
	The~existing~definition~of~'#1'~will~not~be~altered.
}

\msg_new:nnnn { deriv } { derivative-not-defined }
{ Derivative~'#1'~is~not~defined! }
{ You~have~used~#2~with~a~derivative~that~was~never~defined. }

\msg_new:nnnn { deriv } { command-not-defined }
{ Command~'#1'~not~yet~defined! }
{ You~have~used~#2~with~a~derivative~that~was~never~defined. }

%%%%%  Declaring derivatives  %%%%%

\derivset{all}
\bool_lazy_or:nnT { \sys_if_engine_luatex_p: } { \sys_if_engine_xetex_p: }
{
	\DeclareDerivative{\odv}{d}[style-inf = \symup]
	\DeclareDerivative{\mdv}{D}[style-inf = \symup]
	\DeclareDerivative{\fdv}{\delta}
	\DeclareDerivative{\adv}{\Delta}
	\DeclareDerivative{\jdv}{\partial}[misc-add-delims = {fun, var}]
	\DeclareDerivative{\pdv}{\partial}[sep-inf-ord=1, sep-ord-fun=-2, delims-eval = (), delims-eval-/ = ()]
}
\sys_if_engine_pdftex:T
{
	\DeclareDerivative{\odv}{d}[style-inf = \mathrm]
	\DeclareDerivative{\mdv}{D}[style-inf = \mathrm]
	\DeclareDerivative{\fdv}{\delta}
	\DeclareDerivative{\adv}{\Delta}[style-inf = \mathrm]
	\DeclareDerivative{\jdv}{\partial}[misc-add-delims = {fun, var}]
	\DeclareDerivative{\pdv}{\partial}[sep-inf-ord=1, sep-ord-fun=-2, delims-eval = (), delims-eval-/ = ()]
}

\endinput

